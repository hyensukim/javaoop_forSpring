# 🐼 Chapter02 자바와 절차적/구조적 프로그래밍

## 자바 프로그램의 개발과 구동

Java를 개발하고 구동하기 위해서는 JDK, JRE, JVM이 필수적으로 필요하다.

배포의 편리성을 위해 JDK 다운로드 시, JRE와 JVM이 내부적으로 함께 다운로드 된다.

*JDK*는 자바개발도구 로서, 개발을 위한 각 종 서비스를 제공하며, 그 중 JRE 와 JVM이 있다. *JRE*는 자바 개발 환경으로 자바 구동 시 필요 환경을 제공해주며, JVM 부팅 해주는 역할도 한다. JVM은 가상 머신으로 동일한 자바 소스 코드를 OS 마다 각자의 기계어로 실행해주는 역할을 한다(플랫폼으로부터 독립).

추가적으로 JDK 안에 javac.exe 컴파일러가 포함되어 있으며, JRE 안에 java.exe 자바 프로그램 실행기가 포함되어 있다.

## 자바에 존재하는 절차적/구조적 프로그래밍의 유산

객체 지향 프로그래밍 일부에는 절차적/구조적 프로그래밍 기법으로부터 녹여진 부분이 있다.

*절차적 프로그래밍*의 경우 goto를 사용하지 말라는 것으로써 goto는 자바 내에서 사용을 금하도록 하기 위해 예약어로 등록되어 있는 상태이다.

goto를 금한 이유는 사용 시 프로그램 실행 순서가 인간이 이해할 수 없을 정도로 복잡해질 가능성이 있기 때문이다. goto를 사용 시 프로그램의 실행 순서를 이리저리 이동할 수 있게 된다.

구조적 프로그래밍은 함수를 쓰라는 것으로써 이는 중복 코드를 한 곳에 모아서 관리가 가능하며, 논리를 함수 단위로 분리하여 가독성이 높은 코드를 작성할 수 있기 때문이다.

그렇다면 자바 언어에 남겨진 절차적/구조적 프로그래밍의 유산은 어디 있을까? 위에서 언급했듯이 goto를 예약어로 지정하여 사용을 금지한 것과, 이러한 제어의 흐름을 통제하기 위한 제어문이 있다. 또한, 함수의 사용은 클래스 내부에 정의되는 메서드와 같다.

## 다시 보는 main() 메서드 : 메서드 스택 프레임

main() 메서드의 실행 과정에서 메모리를 사용하는 방식을 설명하기 전에 기본 동작을 설명하겠다.

객체 지향 프로그래밍에서 저장 영역은 3개의 영역으로 분할해서 사용한다.

정적 영역, 스택 영역, 힙영역 이렇게 3가지 이다.

이를 *데이터 저장 영역* 이라고 하며, T 메모리 구조라고 한다.

그렇다면 이어서 Start.java 라는 클래스를 한 줄씩 실행될 때마다 T 메모리가 어떻게 수행되는지 살펴보자.

```
public class Start{
	public static void main(String[] args){
		System.out.println("Hello OOP!!!");
	}
}
```

위 코드가 실행 되는 순서를 T 메모리 구조대로 설명해보자

    1. JRE에서 main() 메서드 유무를 확인한다.

    2. 존재하는 경우, JRE에서 JVM 전원을 넣어 부팅을 한다.

    3. JVM이 실행 되면, 전처리 과정이 실행된다.

    4. java.lang 패키지를 정적 영역에 올린다.

    5. import 패키지 또는 실행할 class를 정적 영역에 올린다.

    6. main() 메서드의 중괄호를 만나면, 메인 스택 프레임(호출스택)이 스택영역에 생성된다.

    7. main() 매개변수인 args를 위한 공간이 할당되어 스택에 쌓인다.

    8. main() 메서드 내부 실행문이 실행된다.

    9. 실행 후 main() 메서드 중괄호가 닫히면, 메서드 종료와 함께 T 메모리가 소멸된다.

    10. JVM이 종료되고, JRE에서 사용되던 컴퓨팅 자원들이 운영체제로 반납된다.

## 변수와 메모리: 변수! 너 어디 있니?

```
public class Start2{
	public static void main(String[] args){
		int i;
		i = 10;
		double d = 20.0;
	}
}
```

위의 메인 메서드 실행을 T 메모리로 설명해보자.

```
static(데이터 영역)
- java.lang 패키지
- Start2 클래스

stack(스택 영역)
- main() 메서드 프레임
- 4byte i : 10
- 8byte d : 20.0
- args
```

## 블록 구문과 메모리: 블록 스택 프레임

```
public class Start3{
	pubic static void main(String[] args){
		int i = 10;
		int k = 20;

		if(i == 10){
			int m = k + 5;
			k = m;
		}else{
			int p = k + 10;
			k = p;
		}
		//k = m + p; // if 블록 시작 시, 스택 프레임 안에서 선언된 자원은 if문 종료와 함께 지워지기 때문에, 외부에서 사용이 불가하다.
	}
}
```

위의 메인 메서드 실행을 T 메모리로 설명해보자.

```
static(데이터 영역)
- java.lang 패키지
- Start3 클래스

stack(스택 영역)
- main() 스택 프레임
- args
- 4byte i : 10
- 4byte k : 20
- if 스택 프레임(true)
	- 4byte m : 25
- k : 25
```

위에서 주목할 내용은 if 블록 스택 프레임을 수행하는 중에 if 블록 스택 프레임 외부에 존재하는 변수인 k에 접근이 가능하다는 점이다. 이는, 메모리 상에 k 변수가 존재하기 때문에 당연한 결과이다.

## 지역변수와 메모리: 스택 프레임에 갇혔어요!

T 메모리에는 세 개의 영역이 있는데 변수는 스태틱 영역, 스택 영역, 힙 영역 중 어디에 있는 걸까? 답은  '세 군데 모두' 이다. 세 군데 각각에 있는 변수는 각기 다른 목적을 갖는다.

### stack - 지역변수

스택 프레임 안에 생성딘 변수이다. 따라서 스택 프레임이 사라지면 함께 사라진다.

### static - 클래스 멤버변수

스태틱 영역에 생성된 변수이다. JVM 종료와 함께 사라진다.

### heap - 객체 멤버 변수

객체와 함께 생성되며, 가비지 컬렉터라고 하는 메모리 회수기에 의해 사라진다.

### 메서드 호출과 메모리 : 메서드 스택 프레임2

```
public class Start4{
	public static void main(String[] args){
		int k = 5;
		int m;
		m = square(k);
	}

	private static int square(int k){
		int result;
		k = 25;
		result = k;
		return result;
	}
}
```

위의 코드를 T 메모리 구조로 확인해보자

```
static
- java.lang
- Start4 class

stack
1. main()
- args
- 4bytes k : 5
- 4bytes m : ?

	2. square
	- 4bytes k : 5 -> 25
	- 4bytes result : ? -> 25
	- 4bytes 반환값 : 25

- m : 25
```

위에서 주목할 내용은 main() 메서드 안에 변수 k와 square() 메서드 안에 변수 k는 이름만 같지 별도의 공간을 갖는다.

이를 `Call By Value(값에 의한 호출)` 이라고 한다. 따라서, square 변수 안에 k 값에 어떤값을 담아도, main() 메서드 안에 변수값에는 영향을 미치지 않는다.

위에 main() 메서드와 square() 메서드 간에 서로 접근할 수는 없다.

main() 메서드 내부에 square() 메서드 실행 중에 square() 내부에서 main() 내부의 지역변수에 접근이 가능할 것이라고 생각할 수 있지만 자바 자체에서 금지시켜놨다.

즉, 메서드 간에 값을 전달하거나 반환하는 방법은 메서드의 인자와 반환값으로만 가능하다는 점이 중요하다. 물론, 전역 변수로 전달이 가능하지만, 그러한 이유에서 전역변수를 가급적 사용하지 않는 것이 좋다.


## 전역 변수와 메모리: 전역 변수 사용하지 말라니까요!

위에 언급한 내용에 대해 부가 설명하자면, 메서드 간에 값을 전달하는 방법으로 전역변수의 사용도 있다.

```
public class Starts5{
	static int share;

	public static void main(String[] args){
		share = 55;
		int k = fun(5,7);
		System.out.println(share);
	}

	private static int fun(int m, int p){
		share = m+p;
		return m - p;
	}
}
```

위에서 기억해야할 점은 '지역변수는 스택 프레임에 `종속적` 이라는 것' 과, '전역변수는 스택 프레임에 `독립적` 이라는 것'이다.

### 전역 변수를 사용하지 말라는 이유는 무엇일까?

프로젝트 규모가 커질수록 전역 변수의 값이 어디서 대입되었는지 추적하기가 어려워 변수값을 제어하기가 어려워지기 때문이다.

다만, 읽기 전용으로 값을 공유하기 위해 전역 상수로서 사용되는 경우는 많다.


## 멀티 스레드 / 멀티 프로세스의 이해

T메모리 관점에서 멀티 스레드(Multi-Thread)는 스택 영역을 스레드 갯수만큼 분할해서 사용한다.


멀티 프로세스(Multi-Process)는 다수의 데이터 저장 영역, 즉 다수의 T메모리를 갖는다.


즉, 멀티 프로세스는 프로세스 각자의 T메모리가 있고 각자의 고유 공간으로 다른 프로세스 간에 서로 참조가 불가능하다. 반면에 멀티 스레드는 하나의 T메모리만 사용하지만 스택 영역만 분할해서 사용하는 구조이다.


멀티 스레드는 스레드의 스택 영역 간에는 접근이 불가능하지만, 스태틱 영역과 힙 영역은 공유하여 사용하기 때문에 메모리를 상대적으로 적게 사용한다.


멀티 스레드 관점에서 전역 변수 사용의 문제점을 확인해보자.

멀티 스레드엣 스레드1이 전역변수에 값을 10 대입한 뒤 스레드2로 전환되었다.

스레드2 에서는 전역변수에 값을 20 대입한 뒤 다시 스레드1로 전환되었다.

스레드1에서는 전역변수에 10을 대입하였지만 작업 전환 후 값이 20으로 바뀌어 있게 된다. 이는 예상치 못한 값이 나오게 되는 논리적 오류가 발생하게 된다.


이처럼 쓰기 가능한 전역변수를 사용하게 되면 `스레드 안정성이 깨진다` 고 표현한다. 이를 보완하는 방법으로 동기화 락(lock)을 방법이 있지만, 이러면 동기식으로 작업을 처리하는 장점이 없어지게 된다.


## 정리 - 객체 지향은 절차적/구조적 프로그래밍의 어깨를 딛고

사실 객체 지향 프로그래밍은 절차적/구조적 프로그래밍의 유산을 많은 부분 간직하고 있다.



연산자, 제어문, 메모리 관리 관계 등등 많은 부분을 차용하고 있다.


따라서 개발자는 절차적/구조적 프로그래밍 기법도 잘 알고 있어야 한다.
