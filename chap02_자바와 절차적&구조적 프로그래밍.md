# 🐼 Chapter02 자바와 절차적/구조적 프로그래밍

## 자바 프로그램의 개발과 구동

Java를 개발하고 구동하기 위해서는 JDK, JRE, JVM이 필수적으로 필요하다.

배포의 편리성을 위해 JDK 다운로드 시, JRE와 JVM이 내부적으로 함께 다운로드 된다.

*JDK*는 자바개발도구 로서, 개발을 위한 각 종 서비스를 제공하며, 그 중 JRE 와 JVM이 있다. *JRE*는 자바 개발 환경으로 자바 구동 시 필요 환경을 제공해주며, JVM 부팅 해주는 역할도 한다. JVM은 가상 머신으로 동일한 자바 소스 코드를 OS 마다 각자의 기계어로 실행해주는 역할을 한다(플랫폼으로부터 독립).

추가적으로 JDK 안에 javac.exe 컴파일러가 포함되어 있으며, JRE 안에 java.exe 자바 프로그램 실행기가 포함되어 있다.

## 자바에 존재하는 절차적/구조적 프로그래밍의 유산

객체 지향 프로그래밍 일부에는 절차적/구조적 프로그래밍 기법으로부터 녹여진 부분이 있다.

*절차적 프로그래밍*의 경우 goto를 사용하지 말라는 것으로써 goto는 자바 내에서 사용을 금하도록 하기 위해 예약어로 등록되어 있는 상태이다.

goto를 금한 이유는 사용 시 프로그램 실행 순서가 인간이 이해할 수 없을 정도로 복잡해질 가능성이 있기 때문이다. goto를 사용 시 프로그램의 실행 순서를 이리저리 이동할 수 있게 된다.

구조적 프로그래밍은 함수를 쓰라는 것으로써 이는 중복 코드를 한 곳에 모아서 관리가 가능하며, 논리를 함수 단위로 분리하여 가독성이 높은 코드를 작성할 수 있기 때문이다.

그렇다면 자바 언어에 남겨진 절차적/구조적 프로그래밍의 유산은 어디 있을까? 위에서 언급했듯이 goto를 예약어로 지정하여 사용을 금지한 것과, 이러한 제어의 흐름을 통제하기 위한 제어문이 있다. 또한, 함수의 사용은 클래스 내부에 정의되는 메서드와 같다.

## 다시 보는 main() 메서드 : 메서드 스택 프레임

main() 메서드의 실행 과정에서 메모리를 사용하는 방식을 설명하기 전에 기본 동작을 설명하겠다.

객체 지향 프로그래밍에서 저장 영역은 3개의 영역으로 분할해서 사용한다.

정적 영역, 스택 영역, 힙영역 이렇게 3가지 이다.

이를 *데이터 저장 영역* 이라고 하며, T 메모리 구조라고 한다.

그렇다면 이어서 Start.java 라는 클래스를 한 줄씩 실행될 때마다 T 메모리가 어떻게 수행되는지 살펴보자.

```
public class Start{
	public static void main(String[] args){
		System.out.println("Hello OOP!!!");
	}
}
```

위 코드가 실행 되는 순서를 T 메모리 구조대로 설명해보자

    1. JRE에서 main() 메서드 유무를 확인한다.

    2. 존재하는 경우, JRE에서 JVM 전원을 넣어 부팅을 한다.

    3. JVM이 실행 되면, 전처리 과정이 실행된다.

    4. java.lang 패키지를 정적 영역에 올린다.

    5. import 패키지 또는 실행할 class를 정적 영역에 올린다.

    6. main() 메서드의 중괄호를 만나면, 메인 스택 프레임(호출스택)이 스택영역에 생성된다.

    7. main() 매개변수인 args를 위한 공간이 할당되어 스택에 쌓인다.

    8. main() 메서드 내부 실행문이 실행된다.

    9. 실행 후 main() 메서드 중괄호가 닫히면, 메서드 종료와 함께 T 메모리가 소멸된다.

    10. JVM이 종료되고, JRE에서 사용되던 컴퓨팅 자원들이 운영체제로 반납된다.


## 변수와 메모리: 변수! 너 어디 있니?

```
public class Start2{
	public static void main(String[] args){
		int i;
		i = 10;
		double d = 20.0;
	}
}
```

위의 메인 메서드 실행을 T 메모리로 설명해보자.

```
static(데이터 영역)
- java.lang 패키지
- Start2 클래스

stack(스택 영역)
- main() 메서드 프레임
- 4byte i : 10
- 8byte d : 20.0
- args
```


## 블록 구문과 메모리: 블록 스택 프레임

```
public class Start3{
	pubic static void main(String[] args){
		int i = 10;
		int k = 20;

		if(i == 10){
			int m = k + 5;
			k = m;
		}else{
			int p = k + 10;
			k = p;
		}
		//k = m + p; // if 블록 시작 시, 스택 프레임 안에서 선언된 자원은 if문 종료와 함께 지워지기 때문에, 외부에서 사용이 불가하다.
	}
}
```

위의 메인 메서드 실행을 T 메모리로 설명해보자.

```
static(데이터 영역)
- java.lang 패키지
- Start3 클래스

stack(스택 영역)
- main() 스택 프레임
- args
- 4byte i : 10
- 4byte k : 20
- if 스택 프레임(true)
	- 4byte m : 25
- k : 25
```

위에서 주목할 내용은 if 블록 스택 프레임을 수행하는 중에 if 블록 스택 프레임 외부에 존재하는 변수인 k에 접근이 가능하다는 점이다. 이는, 메모리 상에 k 변수가 존재하기 때문에 당연한 결과이다.

## 지역변수와 메모리: 스택 프레임에 갇혔어요!

T 메모리에는 세 개의 영역이 있는데 변수는 스태틱 영역, 스택 영역, 힙 영역 중 어디에 있는 걸까? 답은  '세 군데 모두' 이다. 세 군데 각각에 있는 변수는 각기 다른 목적을 갖는다.

### stack - 지역변수

스택 프레임 안에 생성딘 변수이다. 따라서 스택 프레임이 사라지면 함께 사라진다.


### static - 클래스 멤버변수

스태틱 영역에 생성된 변수이다. JVM 종료와 함께 사라진다.


### heap - 객체 멤버 변수

객체와 함께 생성되며, 가비지 컬렉터라고 하는 메모리 회수기에 의해 사라진다.


### 메서드 호출과 메모리 : 메서드 스택 프레임2

```
public class Start4{
	public static void main(String[] args){
		int k = 5;
		int m;
		m = square(k);
	}

	private static int square(int k){
		int result;
		k = 25;
		result = k;
		return result;
	}
}
```

위의 코드를 T 메모리 구조로 확인해보자

```
static
- java.lang
- Start4 class

stack
1. main()
- args
- 4bytes k : 5
- 4bytes m : ?

	2. square
	- 4bytes k : 5 -> 25
	- 4bytes result : ? -> 25
	- 4bytes 반환값 : 25

- m : 25
```

위에서 주목할 내용은 main() 메서드 안에 변수 k와 square() 메서드 안에 변수 k는 이름만 같지 별도의 공간을 갖는다.

이를 `Call By Value(값에 의한 호출)` 이라고 한다. 따라서, square 변수 안에 k 값에 어떤값을 담아도, main() 메서드 안에 변수값에는 영향을 미치지 않는다.
