# 🎆 자바와 객체 지향

## 🎇 객체 지향은 인간 지향이다

절차적/구조적 프로그래밍은 인간이 기계를 이해하기 위한 노력에서 크게 벗어나지 못하였다. 이전 프로그래밍 방법을 지양하고  인간 지향적인 프로그래밍을 위해 객체 지향이라는 개념이 탄생했다.

객체를 이해하기 위해 큰 그림을 이해해야 한다.

- 세상에 존재하는 모든 것들은 객체(Object)이다.
- 각각의 사물은 고유하다
- 사물은 속성을 갖는다
- 사물은 행위를 한다

위의 특징들만 보아도 객체가 얼마나 직관적이고 인간 지향적인 개념인지 알 수 있다.

## 🎇 객체 지향의 4대 특성 - 캡! 상추다

캡 - 캡슐화(Encapsulation) : 정보은닉

상 - 상속(~~inhreitance~~): 재사용

추 - 추상화(Abstraction): 모델링

다 - 다형성(Polymorphism): 사용 편의

## 🎇 클래스 vs. 객체 = 붕어빵들 vs. 붕어빵???

붕어빵들과 붕어빵은 클래스와 객체의 관계일까? 아니다.

클래스는 설계도를 의미하며, 객체를 만들 틀을 의미한다.

따라서 이는 붕어빵틀과 붕어빵의 관계가 맞으며, 붕어빵틀은 `팩토리` 라는 단어로 이해하면 쉽다.

대상이 클래스인지 객체인지를 구분할 때, 대상의 속성(필드값)을 물어보면 답이 쉽게 나온다.

Ex) 사람은 몇살인가?, 김연아는 몇살인가?, 동물은 몇 키로인가?, 뽀삐는 몇 키로인가?

위의 예제에서 클래스는 '사람','동물'이고, 객체는 '김연아', '뽀삐'이다.

***즉, 클래스는 `개념` 이고, 객체는 `실체` 를 말한다.***

## 🎇 추상화 : 모델링

사전적 의미의 추상화는 '여러 가지 사물이나 개념에서 공통되는 특성이나 속성 따위를 추출하여 파악하는 작용' 이다. 말이 어렵다...

### 추상화는 모델링이다

추상화란 구체적인 것을 분해해서 관찰자가 관심 있는 특성만 가지고 재조합하는 것이라고 정리할 수 있다.

객체 지향의 4대 특성은 클래스를 통해 구현된다. 이를 실체화 한것이 객체이다. 이 때, 클래스를 이용해 객체를 만들었다는 것을 강조할 때는 object라는 표현보다는 인스턴스라는 표현을 많이 사용한다.

객체 = 클레스의 인스턴스

위의 일반적인 추상화의 뜻을 IT 용어로 이용해 바꾸면,

추상화란 구체적인 것을 분해해서 관심 영역(애플리케이션)에 필요한 특성만 가지고 재조합하는 것 = 모델링

자바 자체에서 객체 지향의 추상화를 class 라는 키워드를 통해 지원하고 있다는 점을 잊지 말자.

### 추상화와 T메모리

추상화 전에 애플리케이션의 경계 즉, 추상화 대상의 경계를 지정해야 한다.

즉, 애플리케이션에서 사용될 객체의 특징 중 필요한 부분만 넣자는 의미이다.

추상화를 한 결과물은 모델이며, 이는 자바 언어에서 클래스로 표현된다.

클래스 모델을 표현하는 국제 표준 표기법이 UML 클래스 다이어그램이다.

이러한 모델은 다시 논리적 모델과 물리적 모델로 나뉘는데, 일반적으로 논리적 모델링 후 물리적으로 모델링을 한다.(추상화 -> 구체화 과정)

위의 과정을 예시로 아래와 같은 과정이 진행된다.

> 실체 -> 추상화(클래스)

객체명 - 미키마우스, 제리

클래스명 - 쥐

- 필드(특징) : 이름, 나이, 꼬리수
- 함수(행위) : 울다()

##### Mouse.java

```
public class Mouse{
    public String name;
    public int age;
    public int countOfTail;

    public void sing(){
        System.out.println(name + " 찍찍!!");
    }
}
```

위의 클래스를 실행하기 위한 클래스 정의

##### MouseDriver.java

```
public class MouseDriver {
    public static void main(String[] args) {
        Mouse mickey = new Mouse();
        mickey.name ="미키";
        mickey.age=85;
        mickey.countOfTail=1;

        mickey.sing();

        mickey = null;

        Mouse jerry = new Mouse();
        jerry.name = "제리";
        jerry.age = 73;
        jerry.countOfTail = 1;
        jerry.sing();

        jerry = null;
    }
  
}
```

위 코드에서 객체 생성 식 과정 중 T메모리의 변화를 설명하면,

##### new Mouse();

- 스태틱 영역 : java.lang , Mouse, MouseDriver 클래스 로딩(Mouse 객체 내부에 필드는 공간 할당 X)
- 스택 영역 : X
- 힙 영역 : Mouse 객체 생성(name = null, age = 0, countOfTail = 0)
- 힙 영역에 메서드는 공간이 할당되지 않고, 스태틱 영역에 하나만 생성이 되는데, 메서드는 굳이 동일한 로직을 여러번 메모리 할당할 필요 없기 때문이다.(메모리 절약)

##### Mouse mickey

- 스택 영역 : mickey

##### 대입문(=)

- Mouse 객체에 대한 주소(참조값)를 참조변수 micky에 할당

##### sing() 메서드 호출

- T 메모리 상 변화 없음

##### mickey = null;

- 참조변수의 참조를 끊는다.
- 가비지 컬렉터에서 힙 메모리 안에 객체를 제거한다.

Jerry도 동일한 구조이다.

### 클래스 멤버 vs. 객체 멤버 = static 멤버 vs. 인스턴스 멤버

객체는 유일무이하게 존재하는 실체이기 때문에 개별적인 속성을 갖는다.

클래스는 개념이면서 분류체계일 뿐이므로 속성을 가질 수 없다. 하지만, Mouse 객체가 모두 같은 값을 갖는 즉, 공통적인 값을 갖는 꼬리 갯수(countOfTail) 속성이 있음에도 Mouse 객체 수만큼 아까운 메모리를 잡아먹고 있다.

이와 같은 경우 static 키워드를 사용하면 된다.

```
public class Mouse{
    public String name;
    public int age;
    public static int countOfTail; // 공통 필드

    public void sing(){
        System.out.println(name + " 찍찍!!");
    }
}
```

위처럼 선언하게 되면, 객체를 만들지 않고 '클래스명.countOfTail' 과 같이 사용할 수 있다.

static 키워드가 붙은 속성은 클래스 멤버 속성이다.

즉, static 키워드 여부에 따라 클래스 멤버와 인스턴스 멤버로 분류된다.

`클래스 멤버 = static 멤버 = 정적 멤버`

`객체 멤버 = 인스턴스 멤버`

정적 속성은 기본적으로 해당 클래스의 모든 객체가 동일한 값을 가질 때 사용한다.

정적 멤버들은 클래스에 들어 있으며, 클래스는 JVM 구동 시 T 메모리 스태틱 영역에 바로 배치되기 때문에 객체 생성과 상관 없이 사용이 가능하다.

같은 맥락으로, main() 메서드가 정적 요소인 이유가, 실행 초기 아무런 객체가 생성되지 않은 상태에서 main() 메서드는 실행되어야 하기 떄문이다.

실무에서는 주로 유틸리티 성 메서드를 사용 시에 정적 메서드로 구성한다. Ex) Math 클래스

또한, 정적 멤버와 인스턴스 멤버는 메모리 할당 시점이 다르다

- 클래스 멤버 : 클래스 로딩 시 할당
- 인스턴스 멤버 : 객체 생성

클래스와 객체의 속성은 별도의 초기화 없이도 사용이 가능하다. 정수형 0, 부동 소수점형 0.0, 논리형 false, 참조형 null.

이는, 멤버 변수는 클래스 내부에서 공용으로 사용되는 성격의 변수이고, 지역변수는 메서드 내부에서만 사용되기 때문에, 별도로 초기화가 필요한 것이다.

## 🎇 상속: 재사용 + 확장

상속은 부모 - 자식 관계로 사용되서는 안된다.

상속은 재사용과 확장으로 이해하고 상위 - 하위 관계로 사용되어야 한다.

상위로 올라갈수록 클래스는 추상적이고, 하위로 내려갈수록 클래스는 구체적이다.

상속관계에서 중요한 문장이 있는데,

- 하위클래스는 상위클래스다

이는, LSP(리스코프 치환 법칙)을 의미한다.

상속은 inheritance가 아니라 extends 말한다.

### 상속의 강력함

```
동물 animal = new 동물();

조류 bird = new 조류();

펭귄 penguin = new 펭귄();

= 객체 지향적인 코드를 할 수 있도록 해준다. = 객체 지향 4대 원칙(캡슐화, 상속, 추상화, 다형성)

동물 animal = new 동물();

동물 bird = new 조류();

동물 penguin = new 펭귄();

```

실제 우리는 펭귄을 동물이라고 부르기도 한다. 이처럼 현실세계의 논리를 코드로 옮길 수 있도록 해준 것이 상속의 강력함 중 하나이다.

그리고 동물[] 타입의 배열에 모든 동물 객체들을 담을 수 있다. 또한, 반복문과 상속받은 메서드를 통해 한줄의 코드로 배열 안의 모든 동물의 메서드를 호출할 수 있게 된다.

### 상속은 is a 관계를 만족해야 하는가?

```
사자 is a 동물 : 사자는 하나의 동물이다.(상속관계를 표현하기 애매하다.)
```

상속 관계를 잘 표현하기 위해서 더 정확한 표현인 `is a kind of` 를 사용한다.

```
펭귄 is a kind of 조류 : 펭귄은 조류의 한 종류이다.(상속관계를 명확히 이해할 수 있다.)
```

> 정리

- 객체 지향의 상속은 상위 클래스의 특성을 재사용하는 것이다.
- 객체 지향의 상속은 상위 클래스의 특성을 확장하는 것이다.
- 객체 지향의 상속은 is a kind of 관계를 만족해야 한다.

### 다중 상속과 자바

❓ 자바는 왜 다중상속을 지원하지 않는가?

✅ 다중 상속의 `다이아몬드 문제` 때문이다.

예를 들어, 인어라는 하위 클래스가 사람과 어류라는 상위 클래스를 다중 상속한 경우, 수영이라는 행위를 할 때 사람의 형태의 수영을 할 지, 아니면 물고기 형태의 수영을 할 지 젛할 수 없는 문제를 말한다.

### 상속과 인터페이스

자바에서는 득보다 실이 많은 다중상속 대신에 인터페이스 를 도입하였다.

그렇다면 인터페이스와 상속을 같은 역할로서 사용하는 것이 좋은가? 하면, 아니다.

인터페이스의 경우 구현할 메서드(행위)를 강제화하기 때문에, `is be able to` 로서 사용하는 것이 맞다.

예를 들어 구현클래스 is able to 인터페이스 라고 하면, 구현클래스는 인터페이스 할 수 있다.

- Wale is able to swimable : 고래는 수영할 수 있다.

자바 API 내에서도 be able to 형ㅌ의 인터페이스를 자주 볼 수 있다.

- Serializable
- Comparalbe
- Cloneable
- Runnable

정리하면,

- 상속은 상위 클래스의 특성(특징, 행위)을 상속해준다.
- 인터페이스는 기능을 구현하도록 강제하게 해준다.

객체지향적인 코드를 위해서는 상위클래스가 물려줄 특성은 풍부할수록 좋고(LSP, 리스코프 치환 원칙), 인터페이스는 구현을 강제하는 메서드가 적을수록 좋다.(ISP, 인터페이스 분할 원칙)

### 상속과 UML 표기법

![img](https://github.com/hyensukim/javaoop_forSpring/blob/main/images/UML%20%EB%8B%A4%EC%9D%B4%EC%95%84%EA%B7%B8%EB%9E%A8.jpg?raw=true)

### 상속과 T메모리

예를 들어 Penguin 클래스와 Animal 클래스가 상속관계 일 때,

T 메모리 구조의 힙 영역 안에 Penguin 클래스 인스턴스 생성 시, Animal 클래스 인스턴스가 함께 생성된다.(실제로는 Object 클래스 인스턴스도 생성)

만약, 참조 변수 클래스 타입이 Animal인 경우,

`Animal 변수명 = new Penguin();`

Penguin 클래스 속성을 사용할 수 없는데, 이는 해당 변수가 Animal 클래스 인스턴스를 참조하고 있기 때문이다.

Penguin 클래스 속성을 사용하기 위해서는, 참조 변수 클래스 타입을 Penguin으로 변경해주던가, 명시적으로 (Penguin) 타입으로 형변환해주면 된다.


## 🎇 다형성: 사용편의성

다형성은 기본적으로 **오버라이딩**과 **오버로딩**을 통해 수행된다.

- 오버라이딩 : 같은 메서드명, 같은 인자 목록, 예외처리로 상위 클래스의 메서드를 재정의.
- 오버로딩 : 같은 메서드명, 다른 인자 목록으로 다수의 메서드를 중복 정의.


### 다형성과 T메모리

Animal 클래스 와 Penguin 클래스가 상속 관계인 경우,

Animal 클래스의 showName() 메서드를 Penguin 클래스에서 재정의 및 동일한 이름의 메서드를 오버로딩(중복 정의) 했다고 가정하자.

상위 클래스의 메서드를 하위 클래스에서 재정의하게 되면, 메서드 호출 시 재정의된 로직이 실행된다.

이는, 하위 클래스에 재정의된 메서드로 인해 상위 클래스 메서드가 가려졌기 때문이다.

`Animal 변수명 = new Penguin();`

위처럼 참조 클래스 타입을 상위 클래스로 사용한 경우에는 어떨까?

***마찬가지로 오버라이딩한 메서드가 호출된다.***


### 다형성이 지원되지 않는 언어

다형성이 지원되지 않는 언어는 오버로딩과 오버라이딩의 편리함을 제공받지 못한다.

✅오버로딩의 편리함

동일한 로직에 메서드임에도 다른 인자 타입을 필요로 하는 경우 오버로딩을 지원하지 않으면, 메서드 마다 다른 메서드명을 지정해줘야 한다는 번거로움이 있다.

✅오버라이딩의 편리함

상위 클래스 타입의 객체 참조 변수에서 하위 클래스가 오버라이딩한 메서드를 자동으로 호출해줌으로써 깔끔한 코드를 유지할 수 있다.(결합성 낮아짐)

다형성은 개발자가 프로그래밍 코드를 작성할 때 사용편의성을 높여준다.
