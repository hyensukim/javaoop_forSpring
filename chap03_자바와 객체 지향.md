# 🐼 자바와 객체 지향

## 객체 지향은 인간 지향이다

절차적/구조적 프로그래밍은 인간이 기계를 이해하기 위한 노력에서 크게 벗어나지 못하였다. 이전 프로그래밍 방법을 지양하고  인간 지향적인 프로그래밍을 위해 객체 지향이라는 개념이 탄생했다.

객체를 이해하기 위해 큰 그림을 이해해야 한다.

- 세상에 존재하는 모든 것들은 객체(Object)이다.
- 각각의 사물은 고유하다
- 사물은 속성을 갖는다
- 사물은 행위를 한다

위의 특징들만 보아도 객체가 얼마나 직관적이고 인간 지향적인 개념인지 알 수 있다.

## 객체 지향의 4대 특성 - 캡! 상추다

캡 - 캡슐화(Encapsulation) : 정보은닉

상 - 상속(~~inhreitance~~): 재사용

추 - 추상화(Abstraction): 모델링

다 - 다형성(Polymorphism): 사용 편의

## 클래스 vs. 객체 = 붕어빵들 vs. 붕어빵???

붕어빵들과 붕어빵은 클래스와 객체의 관계일까? 아니다.

클래스는 설계도를 의미하며, 객체를 만들 틀을 의미한다.

따라서 이는 붕어빵틀과 붕어빵의 관계가 맞으며, 붕어빵틀은 `팩토리` 라는 단어로 이해하면 쉽다.

대상이 클래스인지 객체인지를 구분할 때, 대상의 속성(필드값)을 물어보면 답이 쉽게 나온다.

Ex) 사람은 몇살인가?, 김연아는 몇살인가?, 동물은 몇 키로인가?, 뽀삐는 몇 키로인가?

위의 예제에서 클래스는 '사람','동물'이고, 객체는 '김연아', '뽀삐'이다.

***즉, 클래스는 `개념` 이고, 객체는 `실체` 를 말한다.***

### 추상화 : 모델링

사전적 의미의 추상화는 '여러 가지 사물이나 개념에서 공통되는 특성이나 속성 따위를 추출하여 파악하는 작용' 이다. 말이 어렵다...

#### 추상화는 모델링이다

추상화란 구체적인 것을 분해해서 관찰자가 관심 있는 특성만 가지고 재조합하는 것이라고 정리할 수 있다.

객체 지향의 4대 특성은 클래스를 통해 구현된다. 이를 실체화 한것이 객체이다. 이 때, 클래스를 이용해 객체를 만들었다는 것을 강조할 때는 object라는 표현보다는 인스턴스라는 표현을 많이 사용한다.

객체 = 클레스의 인스턴스

위의 일반적인 추상화의 뜻을 IT 용어로 이용해 바꾸면,

추상화란 구체적인 것을 분해해서 관심 영역(애플리케이션)에 필요한 특성만 가지고 재조합하는 것 = 모델링

자바 자체에서 객체 지향의 추상화를 class 라는 키워드를 통해 지원하고 있다는 점을 잊지 말자.

#### 추상화와 T메모리

추상화 전에 애플리케이션의 경계 즉, 추상화 대상의 경계를 지정해야 한다.

즉, 애플리케이션에서 사용될 객체의 특징 중 필요한 부분만 넣자는 의미이다.

추상화를 한 결과물은 모델이며, 이는 자바 언어에서 클래스로 표현된다.

클래스 모델을 표현하는 국제 표준 표기법이 UML 클래스 다이어그램이다.

이러한 모델은 다시 논리적 모델과 물리적 모델로 나뉘는데, 일반적으로 논리적 모델링 후 물리적으로 모델링을 한다.(추상화 -> 구체화 과정)

위의 과정을 예시로 아래와 같은 과정이 진행된다.

> 실체 -> 추상화(클래스)

객체명 - 미키마우스, 제리

클래스명 - 쥐

- 필드(특징) : 이름, 나이, 꼬리수
- 함수(행위) : 울다()

Mouse.java

```
public class Mouse{
    public String name;
    public int age;
    public int countOfTail;

    public void sing(){
        System.out.println(name + " 찍찍!!");
    }
}
```

위의 클래스를 실행하기 위한 클래스 정의

MouseDriver.java

```
public class MouseDriver {
    public static void main(String[] args) {
        Mouse mickey = new Mouse();
        mickey.name ="미키";
        mickey.age=85;
        mickey.countOfTail=1;

        mickey.sing();

        mickey = null;

        Mouse jerry = new Mouse();
        jerry.name = "제리";
        jerry.age = 73;
        jerry.countOfTail = 1;
        jerry.sing();

        jerry = null;
    }
  
}
```


위 코드에서 객체 생성 식 과정 중 T메모리의 변화를 설명하면,

##### new Mouse();

- 스태틱 영역 : java.lang , Mouse, MouseDriver 클래스 로딩(Mouse 객체 내부에 필드는 공간 할당 X)
- 스택 영역 : X
- 힙 영역 : Mouse 객체 생성(name = null, age = 0, countOfTail = 0)
- 힙 영역에 메서드는 공간이 할당되지 않고, 스태틱 영역에 하나만 생성이 되는데, 메서드는 굳이 동일한 로직을 여러번 메모리 할당할 필요 없기 때문이다.(메모리 절약)

##### Mouse mickey

- 스택 영역 : mickey

##### 대입문(=)

- Mouse 객체에 대한 주소(참조값)를 참조변수 micky에 할당

##### sing() 메서드 호출

- T 메모리 상 변화 없음

##### mickey = null;

- 참조변수의 참조를 끊는다.
- 가비지 컬렉터에서 힙 메모리 안에 객체를 제거한다.
